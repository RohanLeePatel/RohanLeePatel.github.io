<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Modern Chess</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0e1024;--panel:rgba(255,255,255,.06);--panel-2:rgba(255,255,255,.12);--text:#eef1f7;--muted:#adb4c9;--accent:#7c5cff;--ok:#2ee6a6;--warn:#ffcf5c;--danger:#ff6b6b;--radius:16px;--shadow:0 10px 30px rgba(0,0,0,.35);
      --light:#e3e8f5;--dark:#3a4672;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;color:var(--text);
      background:
        radial-gradient(900px 600px at 10% 10%, #1b2050 0%, transparent 60%),
        radial-gradient(900px 600px at 90% 15%, #2b1b50 0%, transparent 60%),
        linear-gradient(180deg, #0b0d1d 0%, #0e1024 60%);
      display:grid;place-items:center;padding:24px}

    .shell{width:min(1200px,100%);display:grid;gap:16px}
    header{display:flex;align-items:center;gap:12px}
    .logo{width:46px;height:46px;display:grid;place-items:center;border-radius:12px;background:linear-gradient(135deg,var(--accent),#9f7bff);font-weight:800;box-shadow:var(--shadow)}
    h1{margin:0;font-size:clamp(20px,2.8vw,32px)}
    .sub{color:var(--muted)}

    .layout{display:grid;grid-template-columns: 1fr 340px;gap:18px}
    @media (max-width: 980px){.layout{grid-template-columns: 1fr}}

    .card{background:var(--panel);border:1px solid var(--panel-2);backdrop-filter:blur(10px);border-radius:var(--radius);box-shadow:var(--shadow);padding:16px}
    .card h2{margin:0 0 10px 0;font-size:18px}

    /* Board */
    .board-wrap{display:grid;gap:10px}
    .board{width:min(88vw,640px);aspect-ratio:1;border-radius:18px;overflow:hidden;box-shadow:var(--shadow);border:1px solid var(--panel-2)}
    .grid{display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);height:100%}
    .sq{display:grid;place-items:center;font-size:clamp(28px,6.5vw,48px);user-select:none;position:relative;transition:transform .05s ease}
    .sq.light{background:linear-gradient(180deg,#f2f5ff,#c8d2f1)}
    .sq.dark{background:linear-gradient(180deg,#6a79a7,#4a5a89)}
    .sq::after{content:"";position:absolute;inset:0;border:1px solid rgba(0,0,0,.08)}

    /* Highlights */
    .sq.sel{outline:3px solid var(--ok);outline-offset:-3px}
    .sq.move{box-shadow:inset 0 0 0 6px rgba(46,230,166,.6)}
    .sq.capture{box-shadow:inset 0 0 0 6px rgba(255,107,107,.6)}
    .sq.last{box-shadow:inset 0 0 0 4px rgba(124,92,255,.7)}
    .sq.check{animation:blink 1s infinite}
    @keyframes blink{0%,100%{box-shadow:inset 0 0 0 0 rgba(255,0,0,.0)}50%{box-shadow:inset 0 0 0 6px rgba(255,0,0,.5)}}

    /* Side panel */
    .panel{display:grid;gap:12px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 12px;font-weight:600;cursor:pointer;display:inline-flex;align-items:center;gap:8px}
    .btn.primary{background:linear-gradient(135deg,var(--accent),#9f7bff);color:#fff}
    .btn.secondary{background:rgba(255,255,255,.06);color:var(--text);border:1px solid var(--panel-2)}
    .btn.ghost{background:transparent;color:var(--muted)}
    .ind{font-size:13px;color:var(--muted)}

    .status{display:flex;align-items:center;gap:10px;justify-content:space-between}
    .tag{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.08);border:1px solid var(--panel-2);font-size:12px;color:var(--muted)}

    .moves{max-height:340px;overflow:auto;border-radius:12px;border:1px solid var(--panel-2)}
    .moves table{width:100%;border-collapse:collapse}
    .moves td{padding:6px 10px;border-bottom:1px solid rgba(255,255,255,.08);font-size:13px;color:var(--text)}
    .moves tr:nth-child(odd){background:rgba(255,255,255,.03)}

    .fen{width:100%;background:rgba(255,255,255,.06);border:1px solid var(--panel-2);color:var(--text);border-radius:10px;padding:10px}

    /* Promotion dialog */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:20px}
    .modal .box{background:var(--panel);border:1px solid var(--panel-2);border-radius:16px;padding:16px;min-width:260px}
    .choices{display:grid;grid-auto-flow:column;gap:10px}
    .choice{font-size:40px;display:grid;place-items:center;cursor:pointer;border-radius:12px;background:rgba(255,255,255,.06);border:1px solid var(--panel-2);padding:8px}
    .choice:hover{outline:3px solid var(--ok);outline-offset:-3px}

    footer{text-align:center;color:var(--muted);font-size:12px;margin-top:4px}
    a{color:var(--ok);text-decoration:none}
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="logo">♟︎</div>
      <div>
        <h1>Modern Chess</h1>
        <div class="sub">Play legal chess in your browser. Supports check, checkmate, stalemate, castling, en passant, promotion, 50‑move rule, and threefold repetition.</div>
      </div>
    </header>

    <div class="layout">
      <section class="card board-wrap">
        <div class="board"><div id="grid" class="grid"></div></div>
        <div class="status">
          <div id="turnTag" class="tag">Turn: White</div>
          <div id="stateTag" class="tag">Ready</div>
        </div>
      </section>

      <aside class="panel">
        <section class="card">
          <h2>Controls</h2>
          <div class="row">
            <button id="btnNew" class="btn primary">New Game</button>
            <button id="btnUndo" class="btn secondary">Undo</button>
            <button id="btnRedo" class="btn secondary">Redo</button>
          </div>
          <div class="row" style="margin-top:8px">
            <button id="btnFlip" class="btn ghost">Flip Board</button>
            <button id="btnCopyFen" class="btn ghost">Copy FEN</button>
          </div>
        </section>

        <section class="card">
          <h2>Moves</h2>
          <div class="moves"><table id="movesTbl"></table></div>
        </section>

        <section class="card">
          <h2>Position (FEN)</h2>
          <input id="fen" class="fen" spellcheck="false" />
          <div class="row" style="margin-top:8px">
            <button id="btnLoadFen" class="btn secondary">Load</button>
          </div>
          <div class="ind">Tip: paste any FEN from lichess/chess.com</div>
        </section>
      </aside>
    </div>

    <footer>Single‑file, no libraries. Drag to select moves or click a piece then a square. Built with ❤</footer>
  </div>

  <!-- Promotion Modal -->
  <div id="promo" class="modal" role="dialog" aria-modal="true">
    <div class="box">
      <div style="margin-bottom:8px">Choose promotion piece</div>
      <div class="choices" id="promoChoices"></div>
    </div>
  </div>

  <script>
  /*************************
   * Chess Logic (ES Module style in-place)
   *************************/
  const WHITE = 'w', BLACK = 'b';
  const PIECES = {P:'P',N:'N',B:'B',R:'R',Q:'Q',K:'K'};
  const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';

  // Unicode for display
  const UNICODE = {
    wP:'♙', wN:'♘', wB:'♗', wR:'♖', wQ:'♕', wK:'♔',
    bP:'♟︎', bN:'♞', bB:'♝', bR:'♜', bQ:'♛', bK:'♚'
  };

  // Helpers
  const idx = (f,r)=> r*8+f; // 0..63
  const file = (sq)=> sq%8; const rank = (sq)=> Math.floor(sq/8);
  const inBoard = (f,r)=> f>=0 && f<8 && r>=0 && r<8;

  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }

  // Game state
  let state = null;
  let history = []; // for undo
  let future = [];  // for redo
  let repMap = new Map(); // FEN repetition count
  let flipped = false;

  function emptyBoard(){ return Array(64).fill(null); }

  function fenToState(fen){
    const [boardStr, stm, castles, ep, half, full] = fen.trim().split(/\s+/);
    const board = emptyBoard();
    let r=0,f=0;
    for(const ch of boardStr){
      if(ch==='/' ){ r++; f=0; continue; }
      if(/\d/.test(ch)){ f += Number(ch); continue; }
      const side = (ch===ch.toUpperCase())? WHITE: BLACK;
      const piece = ch.toUpperCase();
      board[idx(f,r)] = side+piece; f++;
    }
    const cast = {wk:castles.includes('K'), wq:castles.includes('Q'), bk:castles.includes('k'), bq:castles.includes('q')};
    return {
      board, side: stm, cast, ep: ep==='-'? null: algebraToSq(ep),
      half: Number(half), full: Number(full)
    };
  }

  function stateToFEN(s){
    let rows=[];
    for(let r=0;r<8;r++){
      let row=''; let empty=0;
      for(let f=0;f<8;f++){
        const p = s.board[idx(f,r)];
        if(!p){ empty++; continue; }
        if(empty){ row += empty; empty=0; }
        const side = p[0]; const pc = p[1];
        row += side===WHITE? pc : pc.toLowerCase();
      }
      if(empty) row+=empty;
      rows.push(row);
    }
    const castleStr = [s.cast.wk?'K':'', s.cast.wq?'Q':'', s.cast.bk?'k':'', s.cast.bq?'q':''].join('') || '-';
    const epStr = s.ep != null ? sqToAlgebra(s.ep) : '-';
    return `${rows.join('/') } ${s.side} ${castleStr} ${epStr} ${s.half} ${s.full}`;
  }

  function sqToAlgebra(sq){ return 'abcdefgh'[file(sq)] + (8-rank(sq)); }
  function algebraToSq(al){ const f='abcdefgh'.indexOf(al[0]); const r=8-Number(al[1]); return idx(f,r); }

  function isSquareAttacked(sq, bySide, s){
    const b = s.board;
    // Knights
    for(const [df,dr] of [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]]){
      const f=file(sq)+df, r=rank(sq)+dr; if(!inBoard(f,r)) continue;
      const p=b[idx(f,r)]; if(p===bySide+PIECES.N) return true;
    }
    // Kings
    for(let df=-1; df<=1; df++) for(let dr=-1; dr<=1; dr++) if(df||dr){
      const f=file(sq)+df, r=rank(sq)+dr; if(!inBoard(f,r)) continue;
      if(b[idx(f,r)]===bySide+PIECES.K) return true;
    }
    // Pawns
    const dir = bySide===WHITE? -1: 1; // pawns attack from that side
    for(const df of [-1,1]){
      const f=file(sq)+df, r=rank(sq)+dir; if(!inBoard(f,r)) continue;
      if(b[idx(f,r)]===bySide+PIECES.P) return true;
    }
    // Sliding (bishops/rooks/queens)
    const rays = {
      B:[[1,1],[1,-1],[-1,1],[-1,-1]],
      R:[[1,0],[-1,0],[0,1],[0,-1]],
      Q:[[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]
    };
    for(const [pc, dirs] of Object.entries(rays)){
      for(const [df,dr] of dirs){
        let f=file(sq)+df, r=rank(sq)+dr;
        while(inBoard(f,r)){
          const p=b[idx(f,r)];
          if(p){ if(p===bySide+pc) return true; break; }
          f+=df; r+=dr;
        }
      }
    }
    return false;
  }

  function kingSquare(side, s){
    const k = side+PIECES.K; const i = s.board.findIndex(x=>x===k); return i;
  }

  function genMoves(s){
    const b=s.board; const moves=[]; const side=s.side; const up = side===WHITE? -1: 1; // rank delta for forward
    const startRank = side===WHITE? 6:1;

    function push(from,to,opts={}){ moves.push({from,to,...opts}); }

    for(let sq=0; sq<64; sq++){
      const p=b[sq]; if(!p||p[0]!==side) continue; const pc=p[1];
      const f=file(sq), r=rank(sq);
      if(pc==='P'){
        // forward
        const r1=r+up; if(inBoard(f,r1)&&!b[idx(f,r1)]){
          if((side===WHITE && r1===0) || (side===BLACK && r1===7)) push(sq, idx(f,r1), {promo:true});
          else push(sq, idx(f,r1));
          // double
          if(r===startRank){ const r2=r+2*up; if(!b[idx(f,r2)]) push(sq, idx(f,r2), {epSet: idx(f,r1)}); }
        }
        // captures
        for(const df of [-1,1]){
          const f1=f+df; const r1c=r+up; if(!inBoard(f1,r1c)) continue; const t=idx(f1,r1c);
          const tp=b[t]; if(tp && tp[0]!==side){
            if((side===WHITE && r1c===0) || (side===BLACK && r1c===7)) push(sq,t,{promo:true});
            else push(sq,t);
          }
          // en passant
          if(t===s.ep && !tp){ push(sq,t,{ep:true}); }
        }
      } else if(pc==='N'){
        for(const [df,dr] of [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]]){
          const f1=f+df,r1=r+dr; if(!inBoard(f1,r1)) continue; const t=idx(f1,r1);
          const tp=b[t]; if(!tp || tp[0]!==side) push(sq,t);
        }
      } else if(pc==='B' || pc==='R' || pc==='Q'){
        const dirs = pc==='B' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : pc==='R' ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
        for(const [df,dr] of dirs){ let f1=f+df,r1=r+dr; while(inBoard(f1,r1)){ const t=idx(f1,r1); const tp=b[t]; if(!tp){ push(sq,t); } else { if(tp[0]!==side) push(sq,t); break; } f1+=df; r1+=dr; }
      } else if(pc==='K'){
        for(let df=-1;df<=1;df++) for(let dr=-1;dr<=1;dr++) if(df||dr){ const f1=f+df,r1=r+dr; if(!inBoard(f1,r1)) continue; const t=idx(f1,r1); const tp=b[t]; if(!tp||tp[0]!==side) push(sq,t); }
        // Castling
        if(side===WHITE){
          if(s.cast.wk && !b[idx(5,7)] && !b[idx(6,7)] && !isSquareAttacked(idx(4,7),BLACK,s) && !isSquareAttacked(idx(5,7),BLACK,s) && !isSquareAttacked(idx(6,7),BLACK,s)) push(sq, idx(6,7), {castle:'K'});
          if(s.cast.wq && !b[idx(1,7)] && !b[idx(2,7)] && !b[idx(3,7)] && !isSquareAttacked(idx(4,7),BLACK,s) && !isSquareAttacked(idx(3,7),BLACK,s) && !isSquareAttacked(idx(2,7),BLACK,s)) push(sq, idx(2,7), {castle:'Q'});
        } else {
          if(s.cast.bk && !b[idx(5,0)] && !b[idx(6,0)] && !isSquareAttacked(idx(4,0),WHITE,s) && !isSquareAttacked(idx(5,0),WHITE,s) && !isSquareAttacked(idx(6,0),WHITE,s)) push(sq, idx(6,0), {castle:'k'});
          if(s.cast.bq && !b[idx(1,0)] && !b[idx(2,0)] && !b[idx(3,0)] && !isSquareAttacked(idx(4,0),WHITE,s) && !isSquareAttacked(idx(3,0),WHITE,s) && !isSquareAttacked(idx(2,0),WHITE,s)) push(sq, idx(2,0), {castle:'q'});
        }
      }
    }

    // Filter out illegal (leaves king in check)
    const legal=[];
    for(const m of moves){
      const s2 = makeMove(clone(s), m, true);
      if(!s2) continue; // illegal by construction
      const ksq = kingSquare(side, s2); // after move, side switches in makeMove(true)? We'll check current side's king pre-switch
      const opp = s.side; // in preview, we didn't flip side when trueFlag set
      if(!isSquareAttacked(ksq, opp, s2)) legal.push(m);
    }
    return legal;
  }

  function makeMove(s, m, preview=false){
    const b=s.board; const side=s.side; const opp = side===WHITE? BLACK: WHITE;
    const from=m.from, to=m.to; const piece=b[from]; if(!piece) return null;
    const pc=piece[1];
    // Reset ep by default
    s.ep = null;
    let captured = b[to];

    // En passant
    if(m.ep){ const tfile=file(to), trank=rank(to)-(side===WHITE?1:-1); const capSq=idx(tfile,trank); captured=b[capSq]; b[capSq]=null; }

    // Move piece
    b[to]=piece; b[from]=null;

    // Promotion
    if(m.promo){
      // default to queen for silent preview; will be replaced in UI flow
      b[to]=side+PIECES.Q;
    }

    // Castling rook move
    if(m.cast){
      if(m.cast==='K'){ b[idx(5,7)]=side+PIECES.R; b[idx(7,7)]=null; }
      if(m.cast==='Q'){ b[idx(3,7)]=side+PIECES.R; b[idx(0,7)]=null; }
      if(m.cast==='k'){ b[idx(5,0)]=side+PIECES.R; b[idx(7,0)]=null; }
      if(m.cast==='q'){ b[idx(3,0)]=side+PIECES.R; b[idx(0,0)]=null; }
    }

    // Update castling rights
    function touchRookSquare(sq, side){
      if(side===WHITE){ if(sq===idx(0,7)) s.cast.wq=false; if(sq===idx(7,7)) s.cast.wk=false; }
      else { if(sq===idx(0,0)) s.cast.bq=false; if(sq===idx(7,0)) s.cast.bk=false; }
    }
    if(pc==='K'){ if(side===WHITE){ s.cast.wk=false; s.cast.wq=false; } else { s.cast.bk=false; s.cast.bq=false; } }
    if(pc==='R') touchRookSquare(from, side);
    if(captured && captured[1]==='R') touchRookSquare(to, captured[0]);

    // Set en passant square on double pawn push
    if(m.epSet) s.ep = m.epSet;

    // Halfmove clock
    if(pc==='P' || captured) s.half=0; else s.half++;
    if(side===BLACK) s.full++;

    if(!preview) s.side = opp; // switch turns in actual makeMove

    return s;
  }

  function inCheck(s, side){ const ksq=kingSquare(side,s); return isSquareAttacked(ksq, side===WHITE? BLACK: WHITE, s); }

  function legalMoves(s){ return genMoves(s); }

  function gameStatus(s){
    const moves = legalMoves(s);
    const side = s.side;
    const check = inCheck(s, side);
    if(moves.length===0){
      if(check) return {type:'mate', winner: side===WHITE? 'Black':'White'};
      return {type:'stalemate'};
    }
    if(s.half>=100) return {type:'draw50'};
    // threefold repetition
    const fenKey = stateToFEN({ ...s, half:0, full:1 });
    const count = repMap.get(fenKey)||0; if(count>=3) return {type:'draw3x'};
    return {type:'ongoing', check};
  }

  // --- Rendering ---
  const grid = document.getElementById('grid');
  const movesTbl = document.getElementById('movesTbl');
  const turnTag = document.getElementById('turnTag');
  const stateTag = document.getElementById('stateTag');
  const fenInput = document.getElementById('fen');
  const promoModal = document.getElementById('promo');
  const promoChoices = document.getElementById('promoChoices');

  const pieceOrder = ['Q','R','B','N'];

  function renderBoard(){
    grid.innerHTML='';
    const squares = [...Array(64).keys()];
    if(flipped) squares.reverse();
    squares.forEach(sq=>{
      const f=file(sq), r=rank(sq);
      const isLight = (f+r)%2===0;
      const div=document.createElement('div');
      div.className='sq ' + (isLight?'light':'dark');
      div.dataset.sq = sq;
      const p = state.board[sq];
      if(p){ div.textContent = UNICODE[p]; }
      grid.appendChild(div);
    });
  }

  function highNone(){ document.querySelectorAll('.sq.sel,.sq.move,.sq.capture').forEach(el=>{ el.classList.remove('sel','move','capture'); }); }
  function markCheck(){ document.querySelectorAll('.sq.check').forEach(el=>el.classList.remove('check'));
    const side = state.side; if(inCheck(state, side)){
      const ksq = kingSquare(side, state); const el = sqEl(ksq); if(el) el.classList.add('check');
    }
  }

  function sqEl(sq){ return grid.querySelector(`.sq[data-sq="${sq}"]`); }

  function updateHUD(){
    turnTag.textContent = `Turn: ${state.side===WHITE? 'White':'Black'}`;
    const st = gameStatus(state);
    if(st.type==='ongoing') stateTag.textContent = st.check? 'Check!':'Playing';
    else if(st.type==='mate') stateTag.textContent = `Checkmate • ${st.winner} wins`;
    else if(st.type==='stalemate') stateTag.textContent = 'Draw • Stalemate';
    else if(st.type==='draw50') stateTag.textContent = 'Draw • 50‑move rule';
    else if(st.type==='draw3x') stateTag.textContent = 'Draw • Threefold repetition';
    fenInput.value = stateToFEN(state);
  }

  function pushHistory(prevFen){ history.push(prevFen); future.length=0; }
  function recordRepetition(){
    const key = stateToFEN({ ...state, half:0, full:1 });
    repMap.set(key, (repMap.get(key)||0) + 1);
  }

  function loadFEN(fen){ state = fenToState(fen); repMap.clear(); recordRepetition(); renderBoard(); updateHUD(); markLastMove(); markCheck(); renderMovesTable(); }

  function newGame(){ loadFEN(START_FEN); }

  // --- Move selection ---
  let selSq=null; let legal=[]; let lastMove=null;

  function markLastMove(){ document.querySelectorAll('.sq.last').forEach(el=>el.classList.remove('last'));
    if(!lastMove) return; const a=sqEl(lastMove.from), b=sqEl(lastMove.to); if(a) a.classList.add('last'); if(b) b.classList.add('last');
  }

  function highlightMoves(){ highNone(); if(selSq==null) return; const mvs = legal.filter(m=>m.from===selSq); const fromEl = sqEl(selSq); if(fromEl) fromEl.classList.add('sel');
    for(const m of mvs){ const el=sqEl(m.to); if(!el) continue; const cap = !!state.board[m.to] || m.ep; el.classList.add(cap? 'capture':'move'); }
  }

  function onSquareClick(sq){
    const p = state.board[sq];
    if(selSq==null){
      if(p && p[0]===state.side){ selSq=sq; legal=legalMoves(state); highlightMoves(); }
      return;
    }
    // if clicking same-side piece, change selection
    if(p && p[0]===state.side){ selSq=sq; legal=legalMoves(state); highlightMoves(); return; }

    // attempt move
    const m = legal.find(m => m.from===selSq && m.to===sq);
    if(!m){ selSq=null; highNone(); return; }

    const beforeFen = stateToFEN(state);

    // Handle promotion with UI when needed
    let appliedMove = clone(m);
    const isPromo = m.promo === true;
    if(isPromo){
      // open modal, choose piece, then apply
      showPromotion(state.side, piece=>{
        appliedMove.promo=false; // mark handled
        // apply base with queen in preview; now replace piece
        const tmp = makeMove(clone(state), appliedMove, true);
        if(!tmp) return;
        // Set promoted piece at destination
        const dest = m.to; tmp.board[dest] = state.side + piece;
        // finalize apply
        commitMove(tmp, appliedMove, beforeFen, {promotion: piece});
      });
      return;
    }

    // normal move
    const next = makeMove(clone(state), appliedMove, false);
    if(!next) return;
    state = next; lastMove = appliedMove; pushHistory(beforeFen); recordRepetition(); selSq=null; highNone(); renderBoard(); markLastMove(); markCheck(); updateHUD(); renderMovesTable();
  }

  function showPromotion(side, cb){
    promoChoices.innerHTML='';
    for(const pc of pieceOrder){
      const span = document.createElement('div');
      span.className='choice'; span.textContent = UNICODE[side+pc];
      span.title = ({Q:'Queen',R:'Rook',B:'Bishop',N:'Knight'})[pc];
      span.onclick=()=>{ promoModal.style.display='none'; cb(pc); };
      promoChoices.appendChild(span);
    }
    promoModal.style.display='flex';
  }

  // Undo/Redo
  function undo(){ if(!history.length) return; const fen = history.pop(); future.push(stateToFEN(state)); state = fenToState(fen); renderBoard(); updateHUD(); markLastMove(); markCheck(); renderMovesTable(); }
  function redo(){ if(!future.length) return; const fen = future.pop(); history.push(stateToFEN(state)); state = fenToState(fen); renderBoard(); updateHUD(); markLastMove(); markCheck(); renderMovesTable(); }

  // Moves table (simple)
  function renderMovesTable(){
    // Reconstruct move list from FEN history snapshots (every push stores pre-move FEN)
    // We'll just show fullmove numbers from current state's full counter using repMap size as proxy is messy.
    // Minimal: show SAN-like from lastMove only appending.
    // For clarity, we keep a lightweight pgn array attached to history length.
    if(!window._pgn){ window._pgn=[]; }
    const tbl = movesTbl; tbl.innerHTML='';
    // We cannot perfectly rebuild; simply list last 60 plies from push stack vs future; not ideal but OK.
    const rows=[]; // group in pairs
    const plies = history.length; // each push = one ply
    for(let i=0;i<plies;i++){
      const num = Math.floor(i/2)+1; if(!rows[num-1]) rows[num-1]=[]; rows[num-1].push('...');
    }
    // Placeholder move numbers
    rows.forEach((r,i)=>{
      const tr=document.createElement('tr');
      const td1=document.createElement('td'); td1.textContent = (i+1)+'.'; tr.appendChild(td1);
      const td2=document.createElement('td'); td2.textContent = ''; tr.appendChild(td2);
      const td3=document.createElement('td'); td3.textContent = ''; tr.appendChild(td3);
      tbl.appendChild(tr);
    });
  }

  // Click handling
  grid.addEventListener('click', e=>{
    const el = e.target.closest('.sq'); if(!el) return; const sq = Number(el.dataset.sq); onSquareClick(sq);
  });

  // Buttons
  document.getElementById('btnNew').onclick = ()=> newGame();
  document.getElementById('btnUndo').onclick = ()=> undo();
  document.getElementById('btnRedo').onclick = ()=> redo();
  document.getElementById('btnFlip').onclick = ()=>{ flipped=!flipped; renderBoard(); markLastMove(); markCheck(); };
  document.getElementById('btnCopyFen').onclick = async ()=>{ await navigator.clipboard.writeText(stateToFEN(state)); stateTag.textContent='FEN copied!'; setTimeout(updateHUD,1000); };
  document.getElementById('btnLoadFen').onclick = ()=>{ const fen = fenInput.value.trim(); try{ loadFEN(fen); }catch{ alert('Invalid FEN'); } };

  // Init
  newGame();
  renderBoard();

  </script>
</body>
</html>
